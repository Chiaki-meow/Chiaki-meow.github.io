<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="cn"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://chiaki-meow.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://chiaki-meow.github.io/" rel="alternate" type="text/html" hreflang="cn"/><updated>2025-07-22T13:42:40+08:00</updated><id>https://chiaki-meow.github.io/feed.xml</id><subtitle>A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. </subtitle><entry><title type="html">《游戏程序员成长编年史》读后感</title><link href="https://chiaki-meow.github.io/blog/2025/thoughts-after-reading-1/" rel="alternate" type="text/html" title="《游戏程序员成长编年史》读后感"/><published>2025-07-15T21:46:00+08:00</published><updated>2025-07-15T21:46:00+08:00</updated><id>https://chiaki-meow.github.io/blog/2025/thoughts-after-reading-1</id><content type="html" xml:base="https://chiaki-meow.github.io/blog/2025/thoughts-after-reading-1/"><![CDATA[<p>今天刚刚结束在网易的引擎沙龙，又是一次同组实习生都有面试/二面机会，只有我一个人被早早淘汰的一天。每每想起这件事，就很难不把自己跟别人比较一番：为什么人家可以准备的那么充分，自己感觉却平平无奇。</p> <p>说实话，回望自己的本科/研究生生涯，总会对一些自己没做过的事情产生莫名的期待，比如我觉得我会很喜欢渲染（虽然我实际上只做过简单的小渲染器、软光栅化、以及raytracing in one weekend），但是实际上有很少考虑到真正优化层面的内容，更多是喜欢效果，喜欢绚丽的场景，也很希望能把它们实现出来。不过到现在为止，好像都没有做过这么大的demo，所以很难不质疑自己做大demo的能力！</p> <p>不过感觉前文都是题外话，主要题外在，这只是给我一个契机，让我沉下心来思考一番，看看更佳成熟的人写的文章和心路历程，重振旗鼓面对新开始的秋招！</p> <p>首先第一部分，就是先安慰自己，有些事情没有机会不是自己的问题，而是没有获得天时地利人和。比如有的时候面试会很明显的感受到面试官和我的技术栈不相关，或者觉得我做的事情对方其实不感兴趣。虽然对于我这种相对来说比较容易受伤的人来说，和你聊天的人对你不感兴趣这件事，对我来说伤害就会比较大：在一个更认可我的技术水平的环境下工作，会让我更有手脚放开的感觉，更容易做主动且快乐的做更多事情。但是事实往往是：不是所有人都会对你感兴趣，有些人会更佳在意你的此时此刻的能力水平，有些人更在意你的性格，有些人更在意你的积极性以及自我鞭策的能力，有些人更在意你的学习能力。每个人都会在自己和项目中各有权重，所以也不会所有人都喜欢/赏识相同的你。早早的发现双方之间没有达成一致的认识也是好事，避免在工作过程中经历这种不契合。相信所有的相遇都是真正的契合！</p> <p>第二部分就是，对自己所做的事情认真对待，并且相信一切事情是有意义的。就像文章里说：很多同学会认为自己做UI、做逻辑对技术力没有足够的提升。但是如果觉得这些事情不好就不做，那也很难在公司里继续待下去。对我来说，这很像大学生要从不喜欢的专业转出之前，必须得在不喜欢的专业里学成年级前几名，才能转到自己喜欢的专业里。不过可能规矩就是这样，如果想快乐的活着，首先不能让别人用规矩把你卡死。同时学习顾煜老师的意见：虽然这些工作本身很简单，但如何提升自己的效率、优化开发简单事情的流程，都是其他同事没时间去想的。在工作时间快做一点，多想一点，更好的证明自己的能力，也许才有换个地方继续努力的契机。</p> <p>第三部分是，如果自己希望做自己想做的事情，或者希望转行，那就需要在转之前努力学习训练，至少了解你要转入的方向，给对方一个选择你的理由。顾煜老师在生涯前期从事客户端的开发工作，根据个人兴趣积累引擎技术，而后又转到引擎、AI等等积累相关经验。我之前一直对于“生涯规划”一词不屑一顾，因为觉得就算你有一定的规划，也会被其他事情打乱或打断。不过反之亦然：如果没有规划，遇到机会的时候也没有转向的可能，所以要持续的摄入，为自己的下一次转向积攒能量。到了真的有展示机会的时候，所有的准备都会为自己的选择提供帮助；就算没有选择的机会，学习自己喜欢的知识也是件快乐的事情。虽然这样可能也是一种自我pua，但还是要真正地说服自己，才能真正地说服别人！</p> <p>道阻且长，行则将至。今天（或者未来）都要好好沉淀，也希望秋招自己也可以顺利收获想要的offer吧TT</p> <h3 id="链接">链接</h3> <p><a href="https://zhuanlan.zhihu.com/p/25856505">《游戏程序员成长编年史》 - 顾煜</a></p>]]></content><author><name></name></author><category term="life"/><category term="thoughts,"/><category term="reading"/><summary type="html"><![CDATA[周末面网易碰壁之后，选择读《游戏程序员成长编年史》，得到的一些感想和思考]]></summary></entry><entry><title type="html">图形开发相关面经分享整理1.0</title><link href="https://chiaki-meow.github.io/blog/2025/interview-experience-1/" rel="alternate" type="text/html" title="图形开发相关面经分享整理1.0"/><published>2025-04-25T04:30:00+08:00</published><updated>2025-04-25T04:30:00+08:00</updated><id>https://chiaki-meow.github.io/blog/2025/interview-experience-1</id><content type="html" xml:base="https://chiaki-meow.github.io/blog/2025/interview-experience-1/"><![CDATA[<p>以下内容是我+chatgpt联手整理的！可靠性性不能完全保证，做为我自己留存学习用:) 欢迎大家一起学习分享和参考！</p> <h1 id="图形学">图形学：</h1> <h2 id="图形渲染管线原理">图形渲染管线原理：</h2> <p>正常分为四个阶段 - 应用程序阶段、几何阶段、光栅化阶段和像素处理阶段。</p> <p>https://github.com/ssloy/tinyrenderer</p> <h3 id="vertex-shader--fragment-shader">Vertex Shader &amp; Fragment Shader</h3> <p>在现代渲染管线（Graphics Pipeline）中，<strong>Vertex Shader（顶点着色器）</strong> 和 <strong>Fragment Shader（片段着色器）</strong> 扮演着不同的角色：</p> <p><strong>Vertex Shader 负责：</strong></p> <p>1️⃣ <strong>顶点变换</strong>（Model Space → Clip Space → Screen Space）</p> <p>2️⃣ <strong>法线变换</strong>（用于光照计算）</p> <p>3️⃣ <strong>纹理坐标计算</strong>（用于纹理映射）</p> <p>4️⃣ <strong>顶点颜色计算</strong>（可用于渐变色、顶点动画）</p> <p><strong>光栅化（Rasterization）</strong>（固定管线，不属于 FS）</p> <p>•由 GPU <strong>将顶点数据转换为像素级 Fragment</strong></p> <p>•计算插值数据（颜色、纹理坐标、法线等）</p> <p><strong>Fragment Shader 负责：</strong></p> <p>1️⃣ <strong>颜色计算</strong>（包括纹理采样、光照计算）</p> <p>2️⃣ <strong>透明度处理</strong>（Alpha Blending、Alpha Test）</p> <p>3️⃣ <strong>阴影、法线贴图等高级效果</strong></p> <p>4️⃣ <strong>后处理（Post-processing）</strong>（如 HDR、Bloom）</p> <h3 id="采样原理">采样原理：</h3> <h3 id="pbr">PBR：</h3> <p><strong>PBR（Physically Based Rendering，基于物理的渲染）</strong> 是一种 <strong>基于物理真实的光照计算</strong> 方法。它的目标是 <strong>模拟现实世界中的光线反射、吸收和散射</strong>，让材质看起来更加真实。</p> <p>PBR 主要有两个核心部分：</p> <p><strong>BRDF（双向反射分布函数，Bidirectional Reflectance Distribution Function）</strong></p> <p>计算 <strong>光线如何与表面相互作用</strong></p> <p>结合 <strong>漫反射（Diffuse）+ 镜面反射（Specular）</strong></p> <p><strong>IBL（基于图像的光照，Image-Based Lighting）</strong></p> <p>通过 <strong>环境贴图</strong> 模拟 <strong>复杂光源对物体的影响</strong></p> <p>让物体 <strong>更真实地适应环境光照</strong></p> <p><strong>PBR 主要公式：Cook-Torrance 反射模型</strong></p> <p>PBR 采用 <strong>Cook-Torrance BRDF</strong> 来计算光照，公式如下：</p> \[f(l, v) = \frac{D(h) \cdot F(v, h) \cdot G(l, v, h)}{4 (n \cdot v) (n \cdot l)}\] <p>其中：</p> <p>•<strong>D(h)</strong> - 法线分布函数（Normal Distribution Function，NDF）</p> <p>•<strong>F(v, h)</strong> - 菲涅尔反射（Fresnel Effect）</p> <p>•<strong>G(l, v, h)</strong> - 几何遮挡函数（Geometric Attenuation）</p> <p>这些因素决定了 <strong>材质的真实感</strong>，比如金属、塑料、玻璃等材质的光照行为。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 计算 Cook-Torrance BRDF</span>
<span class="c1">// DistributionGGX - 计算法线分布</span>
<span class="c1">// FresnelSchlick - 计算菲涅尔效应（角度越大，反射越强）</span>
<span class="kt">float</span> <span class="nf">DistributionGGX</span><span class="p">(</span><span class="n">vec3</span> <span class="n">N</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">H</span><span class="p">,</span> <span class="kt">float</span> <span class="n">roughness</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">a</span> <span class="o">=</span> <span class="n">roughness</span> <span class="o">*</span> <span class="n">roughness</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">NdotH</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">H</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">NdotH2</span> <span class="o">=</span> <span class="n">NdotH</span> <span class="o">*</span> <span class="n">NdotH</span><span class="p">;</span>
    
    <span class="kt">float</span> <span class="n">num</span> <span class="o">=</span> <span class="n">a2</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">denom</span> <span class="o">=</span> <span class="p">(</span><span class="n">NdotH2</span> <span class="o">*</span> <span class="p">(</span><span class="n">a2</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">);</span>
    <span class="n">denom</span> <span class="o">=</span> <span class="mf">3.14159265</span> <span class="o">*</span> <span class="n">denom</span> <span class="o">*</span> <span class="n">denom</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="n">num</span> <span class="o">/</span> <span class="n">denom</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 菲涅尔反射</span>
<span class="n">vec3</span> <span class="nf">FresnelSchlick</span><span class="p">(</span><span class="kt">float</span> <span class="n">cosTheta</span><span class="p">,</span> <span class="n">vec3</span> <span class="n">F0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">F0</span> <span class="o">+</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">F0</span><span class="p">)</span> <span class="o">*</span> <span class="n">pow</span><span class="p">(</span><span class="mf">1.0</span> <span class="o">-</span> <span class="n">cosTheta</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="dx12的raytracing-demo">DX12的raytracing demo：</h3> <h3 id="gbuffer">gbuffer：</h3> <p>主要是把数据全都存在了gbuffer里，针对于多光源场景下，这种计算方法会让我们计算更少的面片数目。但是需要注意的是，gbuffer并不能支持渲染透明面片。</p> <p>在硬件层面上，在vertex shader前会有一些背面剔除的操作。但是物体间相互遮挡的面片仍然会经过vertex shader到fragment shader里。这种情况如果不剔除的话，就会重复计算很多相互遮挡的面片。加上非常多的光源，就会导致我们计算很多实际上看不到的光照数据。</p> <p>因此，有人提出了gbuffer来解决这个问题：延迟渲染会分为geometry pass和lighting pass的部分，geometry pass会在vertex shader里给gbuffer赋值，其中可以包含法线、深度、漫反射强度、镜面反射强度等等；lighting pass会在fragment shader里进行执行。lighting pass会读取gbuffer所存储的信息，在屏幕的每一个像素点上计算光照的贡献度。</p> <p><a href="https://learnopengl-cn.readthedocs.io/zh/latest/05%20Advanced%20Lighting/08%20Deferred%20Shading/">learnOpenGL 延迟渲染发</a></p> <h3 id="webgl是怎么渲染在页面上的">WEBGL是怎么渲染在页面上的：</h3> <h3 id="蒙皮动画系统">蒙皮动画系统：</h3> <h1 id="游戏引擎">游戏引擎：</h1> <h3 id="entity-component-system-ecs"><strong>Entity Component System (ECS)：</strong></h3> <h3 id="raiiresource-acquisition-is-initialization"><strong>RAII（Resource Acquisition Is Initialization）</strong></h3> <p>RAII是 C++ 中的一种 <strong>资源管理</strong> 方式，核心思想是<strong>将资源（如内存、文件句柄、GPU 资源）绑定到对象的生命周期上</strong>，从而实现资源的自动释放，避免手动管理带来的内存泄漏问题。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Texture</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Texture</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">filePath</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">glGenTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">textureID</span><span class="p">);</span>
        <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">textureID</span><span class="p">);</span>
        <span class="c1">// 加载纹理数据（伪代码）</span>
        <span class="n">loadTextureFromFile</span><span class="p">(</span><span class="n">filePath</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="o">~</span><span class="n">Texture</span><span class="p">()</span> <span class="p">{</span>  
        <span class="n">glDeleteTextures</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">textureID</span><span class="p">);</span>  <span class="c1">// 自动释放 GPU 资源</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">bind</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">glBindTexture</span><span class="p">(</span><span class="n">GL_TEXTURE_2D</span><span class="p">,</span> <span class="n">textureID</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">GLuint</span> <span class="n">textureID</span><span class="p">;</span>  <span class="c1">// OpenGL 纹理ID</span>
<span class="p">};</span>
</code></pre></div></div> <h1 id="操作系统">操作系统:</h1> <h3 id="malloc一个16g内存操作系统会发生什么">Malloc一个16g内存，操作系统会发生什么：</h3> <h3 id="如何debug一个大型的应用判断他的瓶颈在哪里">如何Debug一个大型的应用，判断他的瓶颈在哪里：</h3> <h1 id="c">C++：</h1> <h3 id="c特性整理内容">C++特性整理内容：</h3> <p><strong>版本</strong> <strong>主要特性</strong></p> <table> <thead> <tr> <th><strong>版本</strong></th> <th><strong>主要特性</strong></th> </tr> </thead> <tbody> <tr> <td><strong>C++11</strong></td> <td>auto✅、nullptr✅、右值引用✅、std::thread、std::unique_ptr</td> </tr> <tr> <td><strong>C++14</strong></td> <td>泛型 lambda、std::make_unique、二进制字面量</td> </tr> <tr> <td><strong>C++17</strong></td> <td>结构化绑定、std::optional、std::variant、if constexpr</td> </tr> <tr> <td><strong>C++20</strong></td> <td>concepts、std::ranges、std::span、协程</td> </tr> <tr> <td><strong>C++23</strong></td> <td>std::expected、if consteval</td> </tr> </tbody> </table> <h3 id="引用和指针的区别">引用和指针的区别：</h3> <p>https://csguide.cn/cpp/memory/difference_of_pointers_and_ref.html#%E5%8C%BA%E5%88%AB</p> <table> <thead> <tr> <th>指针</th> <th>引用</th> </tr> </thead> <tbody> <tr> <td>指针是一个变量，保存了另一个变量的内存地址</td> <td>引用是另一个变量的别名，与原变量共享内存地址</td> </tr> <tr> <td>指针可以被重新赋值，指向不同的变量</td> <td>引用在<strong>初始化之后不能更改</strong>，始终指向同一个变量</td> </tr> <tr> <td>指针可以为nullptr，不指向任何一个变量</td> <td>引用必须绑定到一个变量，不能为nullptr</td> </tr> <tr> <td>指针需要解引用以 获取/修改 其指向变量的值</td> <td>引用可以直接使用，不需要符号解引用</td> </tr> </tbody> </table> <h3 id="静态static">静态（static）</h3> <p>全局变量：限制作用于，仅在当前文件可见</p> <p>局部变量：改变存储周期，使得变量在整个程序生命周期内存在</p> <p>类的成员变量：所有对象共享，属于类而不是属于对象</p> <p>类的成员函数：不能访问非static成员、不依赖对象</p> <h3 id="类里的static静态成员函数可以被继承吗">类里的static/静态成员函数可以被继承吗：</h3> <p>可以（如果你觉得不override也是继承的话）：</p> <ol> <li>静态成员函数属于类，而不属于对象实例。</li> <li>静态成员函数需要通过类名进行直接调用，而不需要通过对象来访问。比如可以直接调用MyClass::staticFunction()。</li> <li>静态成员函数不能访问类的非静态成员（成员变量或成员函数），因为静态函数没有this指针</li> </ol> <p>静态函数不会像普通的函数一样被继承和重写（毕竟没有this指针），但是派生类可以<strong>直接调用</strong>基类的静态函数。同时，如果派生类声明了一个和基类同名的静态函数，那么派生类将会<strong>隐藏</strong>基类的同名静态函数。这里是隐藏！而不是override</p> <h3 id="类里的static静态成员函数可以是虚函数吗">类里的static/静态成员函数可以是虚函数吗：</h3> <p>不可以：</p> <ol> <li>静态成员函数没有this指针： <ol> <li>静态函数属于类本身，而非对象实例。调用的时候不通过对象调用，因此不存在this指针；</li> <li>虚函数的多态依靠对象的动态类型，其调用需要通过对象的虚函数表（vtable）查找正确的实现，而vtable的访问依赖于this指针</li> </ol> </li> <li>静态函数与对象实例无关： <ol> <li>静态函数的调用不依赖于任何的对象实例，他们只能访问静态成员变量或其他静态函数；</li> <li>虚函数的调用依赖于对象的实例，this指针指向了每个实例的不同属性</li> </ol> </li> <li> <p>静态函数可以通过对象的引用来调用虚函数</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>    
 <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
 <span class="nl">public:</span>
     <span class="k">virtual</span> <span class="kt">void</span> <span class="n">display</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base class display"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    
     <span class="k">static</span> <span class="kt">void</span> <span class="nf">staticDisplay</span><span class="p">(</span><span class="n">Base</span><span class="o">&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="p">{</span>
         <span class="c1">// 通过传入的对象来调用虚函数</span>
         <span class="n">obj</span><span class="p">.</span><span class="n">display</span><span class="p">();</span>  <span class="c1">// 正确：可以通过对象来调用虚函数</span>
     <span class="p">}</span>
 <span class="p">};</span>
    
 <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
 <span class="nl">public:</span>
     <span class="kt">void</span> <span class="n">display</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived class display"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
 <span class="p">};</span>
    
 <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
     <span class="n">Base</span><span class="o">::</span><span class="n">staticDisplay</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>  <span class="c1">// 正确：静态成员函数通过对象来调用虚函数</span>
     <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</code></pre></div> </div> </li> </ol> <h3 id="动态链接库和静态链接库的区别">动态链接库和静态链接库的区别：</h3> <p>动态链接库已经编译好了，但是静态链接库需要跟着程序一起编译之后才能融入到系统的可执行文件里。因此如果我们已经有一个打包好的程序，我们可以直接通过更换动态链接库来实现对于库内部的函数的更新，而不需要去重新编译整个项目来解决这个问题。</p> <h3 id="volatile的作用"><strong>volatile</strong>的作用：</h3> <p>最主要的功能：阻止编译器对于代码的优化，确保每次访问时都重新从内存中读取该变量的值</p> <ol> <li>硬件寄存器：如果不加volatile，代码可能会觉得相同的两次读取硬件寄存器的数值不会改变，不再从硬件中读取相应的数值。</li> <li> <p>多线程处理：</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">volatile</span> <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    
 <span class="c1">// 线程1</span>
 <span class="kt">void</span> <span class="nf">thread1</span><span class="p">()</span> <span class="p">{</span>
     <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
 <span class="p">}</span>
    
 <span class="c1">// 线程2</span>
 <span class="kt">void</span> <span class="nf">thread2</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">flag</span><span class="p">)</span> <span class="p">{</span>
         <span class="c1">// 等待 flag 被线程1设置为 true</span>
     <span class="p">}</span>
     <span class="c1">// 执行一些操作</span>
 <span class="p">}</span>
</code></pre></div> </div> <p>如果没有volatile，编译器可能会假设flag在thread2不会改变，导致thread2进入死循环</p> </li> <li>信号处理</li> </ol> <h3 id="类里默认会实现的函数是什么">类里默认会实现的函数是什么？</h3> <p>默认构造函数：如果显示的定义一个含参构造函数，就不会定义默认构造函数了</p> <p>拷贝构造函数：默认是浅拷贝；如果有需要动态分配资源的内容，需要额外写深拷贝的构造函数</p> <p>拷贝构造运算符：ClassName&amp; operator=(const ClassName&amp; other); 和拷贝构造函数一样，也是浅拷贝</p> <p>析构函数：不会释放动态分配的内存</p> <p>移动构造函数：ClassName(ClassName&amp;&amp; other); 默认的移动构造函数是浅移动</p> <p>移动构造运算符：ClassName&amp; operator=(ClassName&amp;&amp; other); 默认的移动构造运算符也是浅移动</p> <h3 id="实现一个string">实现一个String：</h3> <p>https://www.cnblogs.com/downey-blog/p/10470912.html</p> <p>今天才看完这个链接，感觉总结出来有用的就三个点：</p> <ul> <li>C++需要支持“+”等等的运算符，所以要进行运算符重载</li> <li>需要自己实现一个迭代器</li> <li>支持字符串自动扩容的相关内容</li> </ul> <h3 id="实现一个读写锁">实现一个读写锁：</h3> <p>写在CppPractices里了，除了实现RWLock本身，还需要注意也实现了</p> <h3 id="实现一个shared_ptr">实现一个shared_ptr：</h3> <p>写在CppPractices里了，重点是存T* ptr和int* count，以及重新写移动与拷贝构造/运算符的逻辑。在只对指针进行操作的话会让这个过程变得区别更大。</p> <p>**std::enable_shared_from_this<T>**</T></p> <p>如果类的成员函数内部需要获得shared_ptr<T>，如果直接使用return(this) 会让两个shared_ptr相互独立，并不是共用同一个shared_ptr的引用内容</T></p> <p>通过std::enable_shared_from_this<T>可以让T内部安全的获取指向自己的shared_ptr<t>。</t></T></p> <h3 id="虚函数相关">虚函数相关:</h3> <p>https://cloud.tencent.com/developer/article/1510207</p> <p>虚表vtable保存在静态数据区/全局数据区，每一个对象会有一个指向vtable的指针（vptr，虚指针）</p> <p>虚表：每一个有虚函数的类都有一张vtable，保存了该类所有虚函数的地址</p> <p>虚指针：每一个具体对象都包含一个虚指针，</p> <h2 id="c特性">C++特性</h2> <h3 id="auto">auto</h3> <p><code class="language-plaintext highlighter-rouge">auto</code> 可以在声明变量时自动推导变量类型，并初始化为默认值。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">auto</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>       <span class="c1">// x 被推导为 int</span>
<span class="k">auto</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>     <span class="c1">// y 被推导为 double</span>
<span class="k">auto</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"Hello"</span><span class="p">;</span> <span class="c1">// str 被推导为 const char*</span>

<span class="k">auto</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// ❌ 错误，auto 需要初始化值</span>
</code></pre></div></div> <p>但注意： <code class="language-plaintext highlighter-rouge">auto</code> 必须有初始化值来推导类型，否则会报错</p> <hr/> <p><code class="language-plaintext highlighter-rouge">auto</code> 的特性：</p> <p>指针：<code class="language-plaintext highlighter-rouge">auto</code> 会保持变量的指针或者引用类型：<code class="language-plaintext highlighter-rouge">auto</code> 默认去掉引用，如果需要保持需使用<code class="language-plaintext highlighter-rouge">auto&amp;</code></p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>  <span class="c1">// b 被推导为 int，而不是 int&amp;</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>        <span class="c1">// 修改 b 不会影响 a</span>

<span class="k">auto</span><span class="o">&amp;</span> <span class="n">c</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span> <span class="c1">// c 被推导为 int&amp;</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>        <span class="c1">// 修改 c 会影响 a</span>
</code></pre></div></div> <hr/> <h3 id="noexcept">noexcept：</h3> <p>https://blog.csdn.net/qiuguolu1108/article/details/114796903</p> <h3 id="左值和右值的区别">左值和右值的区别：</h3> <p>左值：可以取地址，因为对象有一个明确的内存地址；可以修改对应的数值。</p> <p>右值：不能取地址；通常是临时变量，并且生命周期非常短。</p> <p>左值引用：T&amp;</p> <p>右值引用：T&amp;&amp;</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 左值引用</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">ref</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>

<span class="c1">// 右值引用</span>
<span class="kt">int</span> <span class="o">&amp;&amp;</span> <span class="n">ref</span> <span class="o">=</span> <span class="mi">10</span><span class="o">+</span><span class="mi">20</span><span class="p">;</span>
</code></pre></div></div> <p>右值引用用来和<strong>移动语义</strong>配合。</p> <h3 id="stdmove和stdforward">std::move()和std::forward()</h3> <p><strong>std::move</strong>：将变量转换为右值引用（T&amp;&amp;）</p> <p><strong>使用场景</strong>：用于<strong>避免拷贝，提高性能</strong>，特别适用于 <strong>大对象转移（如 std::vector, std::string, std::unique_ptr 等）</strong>。其实主要还是进行转移数据，而不是要复制一遍。</p> <p>**std::forward<T>(arg):（完美转发）保持函数模板参数的左值/右值属性**，让参数在转发时不会失去其原始类型，常用于**模板函数**，防止参数不必要的拷贝或移动。</T></p> <p><strong>使用场景</strong>：主要在 <strong>泛型代码（如构造函数转发、工厂模式）</strong> 中，避免左值误用 std::move 导致资源被错误地移动。</p> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">createObject</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...);</span>
<span class="p">}</span>
</code></pre></div></div> <h2 id="c-stl小技巧">C++ STL小技巧</h2> <h3 id="vector-reserve和resize">Vector reserve和resize</h3> <p>reserve()的主要作用是预先分配内存空间，主要更改的是capacity()（容量，看后面会不会需要扩容），而不是直接更改vector的size()</p> <ul> <li>如果在reverse之后再进行push_back()，不会有内存的重新分配的过程！（说明已经预先找到了一个足够大的空间了）</li> </ul> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>

    <span class="c1">// 不调用 reserve，直接添加元素</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Size: "</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">", Capacity: "</span> <span class="o">&lt;&lt;</span> <span class="n">vec</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
		<span class="c1">// Size: 10, Capacity: 16</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>如果没有提前reserve的话，会发现这里的capacity会随着翻倍逐渐变成16！</p> <p>reserve只会增加容量。如果希望减少的话可以考虑用shrink_to_fit()</p> <p>resize()的主要作用是直接去更改vector的size()，这会根据resize的参数去决定是扩大数组还是缩小数组。</p> <ul> <li>如果 n 小于当前大小，元素会被删除。</li> <li>如果 n 大于当前大小，vector 会新增元素，元素会被默认初始化（或者通过提供的值初始化）。</li> </ul> <p>因此，resize其实会调用类型的构造函数或者是析构函数！</p> <h3 id="对象池">对象池</h3> <h2 id="c-coding技巧">C++ Coding技巧</h2> <h3 id="split-string">split string</h3> <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 存在一个以空格为隔断的string s, 如s = "cat dog cat"</span>
<span class="n">istringstream</span> <span class="nf">str</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
<span class="n">string</span> <span class="n">out</span><span class="p">;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">split_s</span><span class="p">;</span>

<span class="k">while</span><span class="p">(</span><span class="n">str</span><span class="o">&gt;&gt;</span><span class="n">out</span><span class="p">){</span>
	<span class="n">split_s</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="coding"/><category term="graphics"/><summary type="html"><![CDATA[整理2025年到四月份的所有C++/图形学涉及到的知识！可能有一些内容还没有完善，但是也是很值得学习的内容:>]]></summary></entry><entry><title type="html">配置conda环境时报错Invoke-Expression的解决办法</title><link href="https://chiaki-meow.github.io/blog/2025/conda-invoke-expression-error/" rel="alternate" type="text/html" title="配置conda环境时报错Invoke-Expression的解决办法"/><published>2025-03-01T02:00:00+08:00</published><updated>2025-03-01T02:00:00+08:00</updated><id>https://chiaki-meow.github.io/blog/2025/conda-invoke-expression-error</id><content type="html" xml:base="https://chiaki-meow.github.io/blog/2025/conda-invoke-expression-error/"><![CDATA[<h3 id="问题">问题</h3> <p>之前在没配过环境的电脑上新安装了anaconda，发现自从安装之后就持续报下面的第一条错误，也就是以Invoke-Expression为开头的错误。</p> <p>同时发生的其他问题：</p> <ul> <li>在powershell里打conda activate base时，报错Invoke-Expression : 无法绑定参数“Command”;</li> <li>在正确配置conda的环境及执行过conda init后，仍然报错：CondaError: Run ‘conda init’ before ‘conda activate’</li> </ul> <p align="center"> <img src="/assets/img/post/25-02-28-conda-invoke/error.png" alt="问题截图" width="60%"/> </p> <p>为了解决这个问题，我尝试过：</p> <ul> <li>修改执行策略(Set-ExecutionPolicy) -&gt; 改为Remote Signed</li> <li>把对应的.ps1文件打开，并且检查具体的内容</li> <li>重装anaconda(虽然重新装上的是miniconda，但这个问题仍然没解决)</li> </ul> <p>在知乎问题下，我发现有些同学遇到的问题和我一样，他没找到解决方案，但是倒是有个缓兵之计：</p> <h3 id="解决">解决</h3> <p>最后在某些解决思路上看到，这个问题可能是<strong>环境变量</strong>的设置问题。因此我去检查了环境变量（通过右键我的电脑-&gt;属性-&gt;高级系统设置-&gt;环境变量）， 然而在检查PATH那一栏的时候并没有发现任何问题。</p> <p>这就很奇怪了！问题出现的图片很明显涉及到了很多环境变量的错误，而且还有一个神秘的错误提示：“ 字符串缺少终止符” ”</p> <p>这里我又重新在powershell里打印了我的环境变量内容，并且把所有的PATH检查了一遍</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">echo</span> <span class="nv">$env</span>:PATH 
</code></pre></div></div> <p>这里大家可以把环境变量全都copy到文本文件里，将分号;替换为换行符来更好的检查:)</p> <p align="center"> <img src="/assets/img/post/25-02-28-conda-invoke/problem.png" alt="问题截图" width="60%"/> </p> <p>在检查的过程中，发现环境变量里有一个神秘的双引号，而我又继续在系统的环境变量里（高级系统设置）确认了一下，并没有相应的内容。</p> <p>而我将对应的环境变量删除并重新输入就完全解决了这个问题！ 因此，很可能是对应的环境变量里有一个隐形字符，随着某个软件的安装一起被装上来了。</p> <h3 id="总结">总结</h3> <p>下次有类似的问题，第一时间检查环境变量！如果环境变量没有问题，可以在powershell里打印一下检查，可能会有不可见字符的影响。</p> <h3 id="参考链接">参考链接</h3> <p>https://www.zhihu.com/question/640937794/answer/3376815197</p>]]></content><author><name></name></author><category term="coding"/><category term="others"/><summary type="html"><![CDATA[配置conda环境时报错Invoke-Expression的可能问题及解决办法]]></summary></entry><entry><title type="html">2025新年祈愿</title><link href="https://chiaki-meow.github.io/blog/2025/thoughts-of-life-2/" rel="alternate" type="text/html" title="2025新年祈愿"/><published>2025-02-18T21:32:13+08:00</published><updated>2025-02-18T21:32:13+08:00</updated><id>https://chiaki-meow.github.io/blog/2025/thoughts-of-life-2</id><content type="html" xml:base="https://chiaki-meow.github.io/blog/2025/thoughts-of-life-2/"><![CDATA[<p>去年匆匆地参考模版搭建了这个个人网站，但是发现持续更新是一件很艰难的事情。我自己总结下来的话可能有如下几个原因：</p> <p>第一，每次在网站上输出内容需要如下的几个步骤：</p> <ul> <li>有一些值得写的事情，预先想好了一个稿子/内容</li> <li>打开vscode/idea，鉴于我平时是一个纯粹的clion用户，开启新的IDE对我来说是一个额外的工作</li> <li>开始打字，打字的过程中还需要优化掉一些口语内容，尤其是我打字很喜欢打括号（）</li> <li>完整的打完一篇文章，不会被其他的事情打断；在打字的同时检查排版，保证文章在网页上可供大家通顺的阅读</li> <li>把md文件push到github上去（没有任何的开销）</li> </ul> <p>但是这些工作对我来说并不是一个，所谓的“SOP”：没有一个list去帮助我明确各种类型的文章，比如笔记、这种奇思妙想等等需要什么架构，主要讲解什么内容……所以就略显复杂。</p> <p>当然，我觉得解决这个问题也并不复杂：以后网站的主要更新会聚焦在编程笔记、个人总结、文娱生活三个方面！分别写一写自己的学习内容、月总结和出去玩等等的体验。感觉这样每个月都会有明确需要更新的内容，应该会让我的更新变得更简单：）</p> <p>第二，我还没有养成一个及时总结或者写技术文章的习惯。对我来说，我觉得技术文章最最重要的一点就是建立个人学习知识库，方便后续自己查询，同时也是方便众多遇到同样问题的同学们查询类似的内容。</p> <p>不过我最近开始复习C++知识点和写新的项目，应该会涉及到很多需要学习的内容，到时候尝试先在Notion上写一份，再copy到这边来！</p> <p>第三，我觉得网站目前和笔记平台的体验区别最大的地方就是，网站有一种再写HTML的美感（）笔记软件会帮你把笔记整理的井井有条，而且可以搭配多种颜色；但是自己在IDE里打字就显得很枯燥，并且插入图片需要不少的操作步骤，感觉很不直观。</p> <p>感觉解决方案就是：要不然把当前的网站替换成传统的笔记网站，要不然搞个插件实现图片的拖拽存储之类的（）虽然后者显得有点大费周章，但感觉是个一劳永逸的办法。</p> <p>好吧，说完为什么不经常更新，接下来应该说说未来规划和期待了！</p> <p>其实很简单，首先就是希望之后可以多多的在网站上更新内容:D，希望更新更多的图形学、C++、实习、校招、生活、旅游等等的信息给大家，并且通过对于网站的建设让我自己顺利毕业、找到理想的工作:)</p> <p>第二个愿望就是希望新的一年可以有一些科研产出！在把本分工作做好之外找更多时间去做一些自己想做的事情:D</p> <p>希望我的愿望可以实现，更希望来博客的每一个同学都能实现自己的愿望。新的一年，天天开心，大家都顺利上岸！</p>]]></content><author><name></name></author><category term="life"/><category term="thoughts"/><summary type="html"><![CDATA[新的一年，对这个网站做一个规划，对自己的未来许一个愿！]]></summary></entry><entry><title type="html">Unity中RenderTexture的sRGB问题</title><link href="https://chiaki-meow.github.io/blog/2024/RenderTexture-sRGB/" rel="alternate" type="text/html" title="Unity中RenderTexture的sRGB问题"/><published>2024-11-13T21:32:13+08:00</published><updated>2024-11-13T21:32:13+08:00</updated><id>https://chiaki-meow.github.io/blog/2024/RenderTexture-sRGB</id><content type="html" xml:base="https://chiaki-meow.github.io/blog/2024/RenderTexture-sRGB/"><![CDATA[<p>在Unity里中，如果使用编辑器(Editor)创建的RenderTexture来渲染相机的某个场景的图片，会发现渲染的场景物体下的真实颜色如果是灰色，在RenderTexture都会是更深的颜色，比如黑色。而从这个renderTexture上所导出的图像，比如附着在某个Texture2D上，后导出的PNG/JPG/bytes都会有更深的颜色。</p> <p>项目里的内容不太方便截图，这里选用了一张同样总结该问题的其他post的图片。</p> <p><img src="/assets/img/post/24-11-13-render-texture-srgb/3.png" alt=""/></p> <p>其原因是：在编辑器下的RenderTexture默认是不打开sRGB的，所以其内部存储的颜色是线性的。</p> <p>在这里最简单的解决办法是，在使用编辑器(Editor)创建RenderTexture时，点击有inspector右上角的三个点，把normal模式切换为debug模式。</p> <p><img src="/assets/img/post/24-11-13-render-texture-srgb/1.png" alt=""/></p> <p>然后在RenderTexture的inspector中，勾选sRGB。 <img src="/assets/img/post/24-11-13-render-texture-srgb/2.png" alt=""/></p> <p>当然，另一种办法是不要在编辑器(Editor)里创建RenderTexture，而是在代码中创建RenderTexture，然后在代码中设置RenderTexture的sRGB属性。</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">RenderTexture</span> <span class="n">rt</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RenderTexture</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">ARGB32</span><span class="p">,</span> <span class="n">RenderTextureReadWrite</span><span class="p">.</span><span class="n">sRGB</span><span class="p">);</span>
</code></pre></div></div> <p>这样就可以保证RenderTexture的颜色和Unity内部相机看到的颜色一致了！</p> <p>参考资料：<br/> [1]: https://qiita.com/120byte/items/44df34fd30057f9642b4 <br/> [2]: https://discussions.unity.com/t/writting-to-rendertexture-comes-out-darker/637617 <br/> [3]: https://blog.csdn.net/lrh3025/article/details/102723090</p>]]></content><author><name></name></author><category term="coding"/><category term="game-engine,"/><category term="graphics"/><summary type="html"><![CDATA[如果使用Unity的RenderTexture来显示某个相机的内容，会发现相机的颜色和RenderTexture的颜色不一致。这是因为RenderTexture默认不打开sRGB，导致其内部存储的颜色其实是线性的。]]></summary></entry><entry><title type="html">写在所有帖子之前</title><link href="https://chiaki-meow.github.io/blog/2024/thoughts-of-life-1/" rel="alternate" type="text/html" title="写在所有帖子之前"/><published>2024-08-25T21:00:00+08:00</published><updated>2024-08-25T21:00:00+08:00</updated><id>https://chiaki-meow.github.io/blog/2024/thoughts-of-life-1</id><content type="html" xml:base="https://chiaki-meow.github.io/blog/2024/thoughts-of-life-1/"><![CDATA[<p>我在最近突然发现我是一个急功近利的人。发现这点的原因是，我一直在尝试走“捷径”，比如问别人有没有什么好的idea，有没有什么我能帮的上忙的内容；或者是喜欢去草草略过很多网上的教程，打开了很多网站，看到了解决方案就结束了，也不会去非常仔细的刨根问底。<br/> 举个例子！最近刚好在看Unity的URP的后处理的部分。URP既然是“通用渲染管线”，后处理方法就变得高度可自定义化了。高度可自定义化的代价也随之而来：除了本身就需要去完成的后处理Shader，还需要自己手写RenderPass。好吧！如果我不使用URP的话，也许我只需要用OnRenderImage就可以直接实现同样的功能了。:&lt; 鉴于学习URP的困难程度，我换了另一种类似OnRenderImage的方法来实现同样的后处理效果。<br/> 这件事情让我觉得很悲伤，因为我不愿意去花时间学习URP到底是什么，我怎么去写RenderPass。所以我有的时候没找到我的出发点到底是“快速完成任务”还是“学习新的内容”。这个困扰同样摆在我对未来的选择之上：我到底是努力做点research尝试读PhD，还是好好做工程去做工程上的图形学，或者不是图形学，而是能让我开心、看到效果的开发呢。<br/> 好吧，感觉还是有点扯远了。今天又有这种感觉的另一个原因是，看到了一个认识的朋友准备去读PhD。而ta选择的道路和我也不太一样，走的路径也不太一样。我就开始思考，是不是ta走的路才是捷径，而我选错了方向呢:&lt; <br/> 我觉得每当我开始考虑路径是不是错了就会开始焦虑。</p> <p>所以还是不要焦虑，继续往前走吧。 继续加油，天天开心！</p>]]></content><author><name></name></author><category term="life"/><category term="thoughts"/><summary type="html"><![CDATA[每天都有新感悟]]></summary></entry><entry><title type="html">Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra</title><link href="https://chiaki-meow.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/" rel="alternate" type="text/html" title="Google Gemini updates: Flash 1.5, Gemma 2 and Project Astra"/><published>2024-05-14T08:00:00+08:00</published><updated>2024-05-14T08:00:00+08:00</updated><id>https://chiaki-meow.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra</id><content type="html" xml:base="https://chiaki-meow.github.io/blog/2024/google-gemini-updates-flash-15-gemma-2-and-project-astra/"><![CDATA[]]></content><author><name></name></author><summary type="html"><![CDATA[We’re sharing updates across our Gemini family of models and a glimpse of Project Astra, our vision for the future of AI assistants.]]></summary></entry><entry><title type="html">Displaying External Posts on Your al-folio Blog</title><link href="https://chiaki-meow.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/" rel="alternate" type="text/html" title="Displaying External Posts on Your al-folio Blog"/><published>2022-04-24T07:20:09+08:00</published><updated>2022-04-24T07:20:09+08:00</updated><id>https://chiaki-meow.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog</id><content type="html" xml:base="https://chiaki-meow.github.io/blog/2022/displaying-external-posts-on-your-al-folio-blog/"><![CDATA[]]></content><author><name></name></author></entry></feed>